# Compiler Project3 Report

11811712 江川

### 访问器模式

和上次 project 一样，由于需要遍历抽象语法树，新实现了访问器的一个子类，用于生成中间代码。

由于在做语法分析时，语法分析器会往语法树的每个节点上插入一些额外的分析信息（如表达式的类型，函数申明类型等），
在实现中间代码生成时，可以很方便地直接从语法树上获取一些需要的信息。

### 生成代码

##### 逻辑表达式的生成

文档中给出的逻辑表达式的生成是直接 `GOTO` 的，并没有算出实际的布尔值，这在有些情况下不能不是很够用。
例如如下代码

```c
int a = b && c;
if (a) {
    // do something
}
```

因此实现中，除了使用文档中给出的 `cond. Exp` 的翻译方法，还另外实现了一套求值算法，能求出某个逻辑表达式的值。例如如上的代码会求值为

```
IF b == #0 GOTO label_false
IF c == #0 GOTO label_false
a := #1
GOTO label_end
LABEL label_false :
a := #0
LABEL label_end :
IF a != #0 GOTO next
```

由于中间代码中缺乏逻辑运算符，因此逻辑值只能以这种 `GOTO` 的形式计算出来，非常的冗余。
因此只有必要时才会使用这种方法进行求值，大多数普通的逻辑表达式仍然使用 `cond. Exp` 翻译方法。

### Bonus

##### break, continue, for 的生成

由于语法分析本身已经支持了 `break`, `continue`, `for` 因此添加对这三个的生成是比较容易的，只需要记录循环开始和循环结束的 label，翻译成对应的 `GOTO` 即可
例如以下对 i 到 m 的所有整数求和可以被正常翻译。

```c
while (1) {
    res = res + i;
    i = i + 1;

    if (i > m) break;
}
```

或者同样语义的 `for`

```kotlin
for j in i .. m {
    res = res + j;
}
```

##### 数组、结构体的生成

为了支持数组和结构体的翻译，首先修改了语义分析中的 `Type` 类，为其增加了一个 `width` 属性，表示一个类型所需要的字节数。
由于不需要支持 char、float 等类型，基本数据类型只有 int， 因此无需考虑内存对齐的问题。
结构体的宽度为每个成员宽度的累加，数组的宽度为内部类型乘大小。

结构体和数组生成的变量实际上是一个地址，如 `int arr[5]`会被翻译为 `DEC arr 20`

在访问结构体成员或数组元素时，会生成对应的偏移量与地址开头相加，得到最终的地址，`arr[1]` 会被翻译成

```
t_index := #1
t_offset := t_index * #4
t_addr := arr + t_offset
```

对于多维数字，我翻译时选择了比较简单的翻译方式，将内存行列颠倒，下面是课件中给出的偏移量计算方式

```
OFFSET(arr[i][j][k]) = i × m × n + j × n + k
```

但在我的代码中，会被计算成这种情况 

```
OFFSET(arr[i][j][k]) = i + j × m + k × m × n
```

这会导致一个问题，`arr[i][j]` 本应该是一个一维数组，但按我的翻译方式，它的内存空间并不是连续的，因此不是一个数组。这点只有在函数传参的时候有影响，不能传子数组作为参数。

数组和结构体可以作为函数参数，传参时若发现类型是结构体或数组，则实际上传递的是它的地址。

##### 优化无用的临时变量

按文档上的方法，有些临时变量可能是没有用处的。例如，对 `Exp1 ASSIGN Exp2` 的翻译是这样的

```
variable = symtab lookup(Exp1.ID)
tp = new place()
code1 = translate Exp(Exp2, tp)
code2 = [variable.name := tp]
code3 = [place := variable.name]
return code1 + code2 + code3
```

这里的最后一句是给 `place` 赋值，但是对于 `a = 123;` 这种语句来说，对 `place` 的赋值可能没有意义。
大多数时候我们只需要这条语句的副作用，不需要他的返回值。只有少数情况如 `b = (a = 123);` 我们才需要赋值语句的返回值。

针对这一点可以进行一些优化，若确定一个表达式的返回值是无用的，那就可以省略该行的翻译。